/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. jmm.jj */
/*@egen*/options {
 LOOKAHEAD = 1;
}

PARSER_BEGIN(Jmm)

public class Jmm/*@bgen(jjtree)*/implements JmmTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTJmmState jjtree = new JJTJmmState();

/*@egen*/
	public static void main(String args[]) throws ParseException {
		Jmm myJmm = new Jmm(System.in);
		SimpleNode root = myJmm.Program(); // returns reference to root node

		root.dump("");
	}
}

PARSER_END(Jmm)
SKIP:{
	" " | "\r" | "\t" 
	//|"\n"
	| <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
	| <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}
TOKEN:{
	< INTEGER: (["0" - "9"])+ >
	| < ADDSUB_OP: "+" | "-">
	| < ARITH_OP: "*" | "/" >
	| < AND : "&&" >
	| < BRACKET_R: "]" >
	| < BRACKET_L: "[" >
	| < BOOL: "true" | "false" >
	| < BOOLEAN: "boolean" >
	| < CLASS : "class" >
	| < CHAV_R : "}" >
	| < CHAV_L : "{" >
	| < EQ : "=" >
	| < EXT : "extends" >
	| < ELSE : "else" >
	| < IF : "if" >
	| < INT: "int" >
	| < LF: "\n" >
	| < LENGTH : "length" >
	| < MAIN : "main" >
	| < NEW : "new" >
	| < NOT : "!" >
	| < PAR_R: ")" >
	| < PAR_L: "(" >
	| < PFINAL : "." >
	| < PUBLIC : "public" >
	| < RET : "return" >
	| < LESSTHAN : "<" >
	| < SCOLON: ";" >
	| < STATIC : "static" >
	| < STR : "String" >
	| < THIS : "this" >
	| < VIRG : "," >
	| < VOID : "void" >
	| < WHILE : "while" >
	| < IDENTIFIER: ["A"-"Z","a"-"z"](["0"-"9","A"-"Z","a"-"z","_"])* >
}

SimpleNode Program(): {/*@bgen(jjtree) Program */
  SimpleNode jjtn000 = new SimpleNode(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Program */
        try {
/*@egen*/
	ClassDeclaration() <LF>/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                }
/*@egen*/ {
		return jjtn000;
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ClassDeclaration(): {/*@bgen(jjtree) ClassDeclaration */
  SimpleNode jjtn000 = new SimpleNode(JJTCLASSDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) ClassDeclaration */
        try {
/*@egen*/
	<CLASS> <IDENTIFIER> [<EXT> <IDENTIFIER>] <CHAV_L>
	(VarDeclaration())*
	AuxClassDeclaration()
	<CHAV_R>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void AuxClassDeclaration()      : {} {
	( <PUBLIC> (MainDeclaration() | MethodDeclaration()) )*
}

void VarDeclaration(): {/*@bgen(jjtree) VarDeclaration */
  SimpleNode jjtn000 = new SimpleNode(JJTVARDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) VarDeclaration */
        try {
/*@egen*/
	Type() <IDENTIFIER> <SCOLON>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void MainDeclaration(): {/*@bgen(jjtree) MainDeclaration */
  SimpleNode jjtn000 = new SimpleNode(JJTMAINDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) MainDeclaration */
        try {
/*@egen*/
	<STATIC> <VOID> <MAIN> <PAR_L> 
	<STR> <BRACKET_L> <BRACKET_R> <IDENTIFIER> <PAR_R>
	<CHAV_L> (LOOKAHEAD(2) VarDeclaration())*
	(Statement())* <CHAV_R>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void MethodDeclaration(): {/*@bgen(jjtree) MethodDeclaration */
  SimpleNode jjtn000 = new SimpleNode(JJTMETHODDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) MethodDeclaration */
        try {
/*@egen*/
	Type() <IDENTIFIER> <PAR_L>
	[Type() <IDENTIFIER> (<VIRG> Type() <IDENTIFIER>)*] <PAR_R>
	<CHAV_L> (LOOKAHEAD(2) VarDeclaration())* (Statement())* 
	<RET> Expression() <SCOLON> <CHAV_R>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Type(): {/*@bgen(jjtree) Type */
  SimpleNode jjtn000 = new SimpleNode(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Type */
        try {
/*@egen*/
	(<INT> (<BRACKET_L> <BRACKET_R>)?)| <BOOLEAN> | <IDENTIFIER>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Statement(): {/*@bgen(jjtree) Statement */
  SimpleNode jjtn000 = new SimpleNode(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Statement */
        try {
/*@egen*/ 
	(<CHAV_L> (Statement())* <CHAV_R>)
	| <IF> <PAR_L> Expression() <PAR_R> Statement() <ELSE> Statement()
	| <WHILE> <PAR_L> Expression() <PAR_R> Statement()
	| (/*@bgen(jjtree) Expression */
           {
             SimpleNode jjtn001 = new SimpleNode(JJTEXPRESSION);
             boolean jjtc001 = true;
             jjtree.openNodeScope(jjtn001);
           }
           try {
/*@egen*/ExpressionAux()/*@bgen(jjtree)*/
           } catch (Throwable jjte001) {
             if (jjtc001) {
               jjtree.clearNodeScope(jjtn001);
               jjtc001 = false;
             } else {
               jjtree.popNode();
             }
             if (jjte001 instanceof RuntimeException) {
               throw (RuntimeException)jjte001;
             }
             if (jjte001 instanceof ParseException) {
               throw (ParseException)jjte001;
             }
             throw (Error)jjte001;
           } finally {
             if (jjtc001) {
               jjtree.closeNodeScope(jjtn001, true);
             }
           }
/*@egen*/            ) <SCOLON>
	| <IDENTIFIER> (<BRACKET_L> Expression() <BRACKET_R>)? ( StatementAux() | (ExpressionRecursive2() <SCOLON>))/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
	/*
	| Expression() <SCOLON>
	| <IDENTIFIER> StatementAux()*/
}

void StatementAux()      : {} {
	<EQ> Expression() <SCOLON>
}

void Expression(): {/*@bgen(jjtree) Expression */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Expression */
        try {
/*@egen*/ 
	<IDENTIFIER> ExpressionRecursive()
	| ExpressionAux()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ExpressionAux()      : {} { 
	(
		<INTEGER>
		| <BOOL> 
		| <THIS>
		| <NEW> ExpressionNew()
		| <NOT> Expression()
		| <PAR_L> Expression() <PAR_R>
	) ExpressionRecursive()
}

void ExpressionNew()      : {} { 
	<INT> <BRACKET_L> Expression() <BRACKET_R>
	| <IDENTIFIER> <PAR_L> <PAR_R>
}	

void ExpressionRecursive()      : {} { 
	ExpressionRecursiveAux()
	| Empty()
}

void ExpressionRecursiveAux()            : {/*@bgen(jjtree) Expression */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Expression */
        try {
/*@egen*/
	(
		(<AND> | <LESSTHAN> | <ADDSUB_OP> | <ARITH_OP>) Expression()
		| <BRACKET_L> Expression() <BRACKET_R>
		| <PFINAL> (<LENGTH> | <IDENTIFIER> <PAR_L> [Expression() (<VIRG> Expression())*] <PAR_R>)
	) ExpressionRecursive()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/* This second recursive functions are helpers for the statement non terminal symbol */
void ExpressionRecursive2()      : {} { 
	ExpressionRecursiveAux2()
	| Empty()
}

void ExpressionRecursiveAux2()            : {/*@bgen(jjtree) Expression */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Expression */
        try {
/*@egen*/
	(
		(<AND> | <LESSTHAN> | <ADDSUB_OP> | <ARITH_OP>) Expression()
		| <PFINAL> (<LENGTH> | <IDENTIFIER> <PAR_L> [Expression() (<VIRG> Expression())*] <PAR_R>)
	) ExpressionRecursive()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/* Epsilon terminal expressed as the non-terminal symbol empty*/
void Empty()      : {}
{
	{}
}